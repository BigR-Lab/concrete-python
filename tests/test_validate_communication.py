#!/usr/bin/env python

"""
TODO: Add tests for...
  - validate_constituency_parse()
  - validate_dependency_parss()
"""

import logging
import sys
import unittest

from testfixtures import LogCapture, StringComparison
from thrift import TSerialization

from concrete.communication.ttypes import Communication, CommunicationType
from concrete.validate import *


class TestCommunication(unittest.TestCase):
    def test_entity_mention_ids(self):
        comm = read_test_comm()
        self.assertTrue(validate_communication(comm))
        self.assertTrue(validate_entity_mention_ids(comm))

        comm.entitySets[0].entityList[0].mentionIdList[0] = 'BAD_ENTITY_MENTION_UUID'
        
        with LogCapture() as log_capture:
            self.assertFalse(validate_entity_mention_ids(comm))
        log_capture.check(('root', 'ERROR', StringComparison(r'.*invalid entityMentionId \(BAD_ENTITY_MENTION_UUID\)')))

    def test_entity_mention_tokenization(self):
        comm = read_test_comm()
        self.assertTrue(validate_communication(comm))
        self.assertTrue(validate_entity_mention_ids(comm))

        comm.entityMentionSets[0].mentionSet[0].tokens.tokenizationId = 'BAD_TOKENIZATION_UUID'
        
        with LogCapture() as log_capture:
            self.assertFalse(validate_entity_mention_tokenization_ids(comm))
        log_capture.check(('root', 'ERROR', StringComparison(r'.*invalid tokenizationId \(BAD_TOKENIZATION_UUID\)')))


class TestRequiredThriftFields(unittest.TestCase):
    def test_check_required_fields(self):
        # When a field is marked as required in a .thrift file, the
        # Python code generated by the Thrift compiler only seems to
        # capture this requirement in the validate() function for the
        # generated class.  While the ThriftGeneratedClass.thrift_spec
        # structure captures the names and types of the fields,
        # thrift_spec does not seem to store any flags indicating
        # whether or not a field is required.
        #
        # Here is the validate() function for the Communication class:
        #
        #    def validate(self):
        #        if self.id is None:
        #            raise TProtocol.TProtocolException(message='Required field id is unset!')
        #        if self.uuid is None:
        #            raise TProtocol.TProtocolException(message='Required field uuid is unset!')
        #        if self.type is None:
        #            raise TProtocol.TProtocolException(message='Required field type is unset!')
        #        return
        # 
        # The validate() function raises an exception when it can't
        # find a required field.  There doesn't seem to be any way to
        # determine whether multiple required fields are missing,
        # aside from assigning a value to the required field and
        # running validate() again.

        comm = Communication()

        with LogCapture() as log_capture:
            self.assertFalse(validate_thrift_object_required_fields_recursively(comm))
        log_capture.check(('root', 'ERROR', "Communication: Required Field 'id' is unset!"))

        comm.id = "ID"
        with LogCapture() as log_capture:
            self.assertFalse(validate_thrift_object_required_fields_recursively(comm))
        log_capture.check(('root', 'ERROR', "Communication: Required Field 'uuid' is unset!"))

        comm.uuid = "TEST_UUID"
        with LogCapture() as log_capture:
            self.assertFalse(validate_thrift_object_required_fields_recursively(comm))
        log_capture.check(('root', 'ERROR', "Communication 'TEST_UUID': Required Field 'type' is unset!"))

        comm.type = CommunicationType.OTHER
        self.assertTrue(validate_thrift_object_required_fields_recursively(comm))


def read_test_comm():
    communication_filename = "tests/testdata/agiga_dog-bites-man.concrete"
    comm = Communication()
    comm_bytestring = open(communication_filename).read()
    TSerialization.deserialize(comm, comm_bytestring)
    return comm


def test_validate_communication():
    unittest.main(buffer=True)


if __name__ == '__main__':
    unittest.main(buffer=True)
