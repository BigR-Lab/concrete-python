#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style,utf8strings
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import concrete.structure.ttypes
import concrete.metadata.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Role(object):
  """
  Enumerated type used to record the relationship between an
  argument and the situation that owns it.
  """
  OTHER_ROLE = 1
  PERSON_ROLE = 2
  TIME_ROLE = 3
  PLACE_ROLE = 4
  AGENT_ROLE = 5
  VICTIM_ROLE = 6
  INSTRUMENT_ROLE = 7
  VEHICLE_ROLE = 8
  ARTIFACT_ROLE = 9
  PRICE_ROLE = 10
  ORIGIN_ROLE = 11
  DESTINATION_ROLE = 12
  BUYER_ROLE = 13
  SELLER_ROLE = 14
  BENEFICIARY_ROLE = 15
  GIVER_ROLE = 16
  RECIPIENT_ROLE = 17
  MONEY_ROLE = 18
  ORG_ROLE = 19
  ATTACKER_ROLE = 20
  TARGET_ROLE = 21
  ENTITY_ROLE = 22
  POSITION_ROLE = 23
  DEFENDANT_ROLE = 24
  ADJUDICATOR_ROLE = 25
  PROSECUTOR_ROLE = 26
  CRIME_ROLE = 27
  PLAINTIFF_ROLE = 28
  SENTENCE_ROLE = 29
  TIME_WITHIN_ROLE = 30
  TIME_STARTING_ROLE = 31
  TIME_ENDING_ROLE = 32
  TIME_BEFORE_ROLE = 33
  TIME_AFTER_ROLE = 34
  TIME_HOLDS_ROLE = 35
  TIME_AT_BEGINNING_ROLE = 36
  TIME_AT_END_ROLE = 37
  RELATION_SOURCE_ROLE = 38
  RELATION_TARGET_ROLE = 39

  _VALUES_TO_NAMES = {
    1: "OTHER_ROLE",
    2: "PERSON_ROLE",
    3: "TIME_ROLE",
    4: "PLACE_ROLE",
    5: "AGENT_ROLE",
    6: "VICTIM_ROLE",
    7: "INSTRUMENT_ROLE",
    8: "VEHICLE_ROLE",
    9: "ARTIFACT_ROLE",
    10: "PRICE_ROLE",
    11: "ORIGIN_ROLE",
    12: "DESTINATION_ROLE",
    13: "BUYER_ROLE",
    14: "SELLER_ROLE",
    15: "BENEFICIARY_ROLE",
    16: "GIVER_ROLE",
    17: "RECIPIENT_ROLE",
    18: "MONEY_ROLE",
    19: "ORG_ROLE",
    20: "ATTACKER_ROLE",
    21: "TARGET_ROLE",
    22: "ENTITY_ROLE",
    23: "POSITION_ROLE",
    24: "DEFENDANT_ROLE",
    25: "ADJUDICATOR_ROLE",
    26: "PROSECUTOR_ROLE",
    27: "CRIME_ROLE",
    28: "PLAINTIFF_ROLE",
    29: "SENTENCE_ROLE",
    30: "TIME_WITHIN_ROLE",
    31: "TIME_STARTING_ROLE",
    32: "TIME_ENDING_ROLE",
    33: "TIME_BEFORE_ROLE",
    34: "TIME_AFTER_ROLE",
    35: "TIME_HOLDS_ROLE",
    36: "TIME_AT_BEGINNING_ROLE",
    37: "TIME_AT_END_ROLE",
    38: "RELATION_SOURCE_ROLE",
    39: "RELATION_TARGET_ROLE",
  }

  _NAMES_TO_VALUES = {
    "OTHER_ROLE": 1,
    "PERSON_ROLE": 2,
    "TIME_ROLE": 3,
    "PLACE_ROLE": 4,
    "AGENT_ROLE": 5,
    "VICTIM_ROLE": 6,
    "INSTRUMENT_ROLE": 7,
    "VEHICLE_ROLE": 8,
    "ARTIFACT_ROLE": 9,
    "PRICE_ROLE": 10,
    "ORIGIN_ROLE": 11,
    "DESTINATION_ROLE": 12,
    "BUYER_ROLE": 13,
    "SELLER_ROLE": 14,
    "BENEFICIARY_ROLE": 15,
    "GIVER_ROLE": 16,
    "RECIPIENT_ROLE": 17,
    "MONEY_ROLE": 18,
    "ORG_ROLE": 19,
    "ATTACKER_ROLE": 20,
    "TARGET_ROLE": 21,
    "ENTITY_ROLE": 22,
    "POSITION_ROLE": 23,
    "DEFENDANT_ROLE": 24,
    "ADJUDICATOR_ROLE": 25,
    "PROSECUTOR_ROLE": 26,
    "CRIME_ROLE": 27,
    "PLAINTIFF_ROLE": 28,
    "SENTENCE_ROLE": 29,
    "TIME_WITHIN_ROLE": 30,
    "TIME_STARTING_ROLE": 31,
    "TIME_ENDING_ROLE": 32,
    "TIME_BEFORE_ROLE": 33,
    "TIME_AFTER_ROLE": 34,
    "TIME_HOLDS_ROLE": 35,
    "TIME_AT_BEGINNING_ROLE": 36,
    "TIME_AT_END_ROLE": 37,
    "RELATION_SOURCE_ROLE": 38,
    "RELATION_TARGET_ROLE": 39,
  }

class JustificationType(object):
  """
  The way in which the justification's mention provides evidence
  for the situation.
  """
  DIRECT_MENTION = 1
  IMPLICIT = 2

  _VALUES_TO_NAMES = {
    1: "DIRECT_MENTION",
    2: "IMPLICIT",
  }

  _NAMES_TO_VALUES = {
    "DIRECT_MENTION": 1,
    "IMPLICIT": 2,
  }

class EventType(object):
  OTHER_EVENT = 1
  BUSINESS_DECLARE_BANKRUPTCY_EVENT = 2
  BUSINESS_END_ORG_EVENT = 3
  BUSINESS_MERGE_ORG_EVENT = 4
  BUSINESS_START_ORG_EVENT = 5
  CONFLICT_ATTACK_EVENT = 6
  CONFLICT_DEMONSTRATE_EVENT = 7
  CONTACT_MEET_EVENT = 8
  CONTACT_PHONE_WRITE_EVENT = 9
  JUSTICE_ACQUIT_EVENT = 10
  JUSTICE_APPEAL_EVENT = 11
  JUSTICE_ARREST_JAIL_EVENT = 12
  JUSTICE_CHARGE_INDICT_EVENT = 13
  JUSTICE_CONVICT_EVENT = 14
  JUSTICE_EXECUTE_EVENT = 15
  JUSTICE_EXTRADITE_EVENT = 16
  JUSTICE_FINE_EVENT = 17
  JUSTICE_PARDON_EVENT = 18
  JUSTICE_RELEASE_PAROLE_EVENT = 19
  JUSTICE_SENTENCE_EVENT = 20
  JUSTICE_SUE_EVENT = 21
  JUSTICE_TRIAL_HEARING_EVENT = 22
  LIFE_BE_BORN_EVENT = 23
  LIFE_DIE_EVENT = 24
  LIFE_DIVORCE_EVENT = 25
  LIFE_INJURE_EVENT = 26
  LIFE_MARRY_EVENT = 27
  MOVEMENT_TRANSPORT_EVENT = 28
  PERSONNEL_ELECT_EVENT = 29
  PERSONNEL_END_POSITION_EVENT = 30
  PERSONNEL_NOMINATE_EVENT = 31
  PERSONNEL_START_POSITION_EVENT = 32
  QUOTATION_DEFINITE_EVENT = 33
  QUOTATION_POSSIBLE_EVENT = 34
  TRANSACTION_TRANSFER_MONEY_EVENT = 35
  TRANSACTION_TRANSFER_OWNERSHIP_EVENT = 36

  _VALUES_TO_NAMES = {
    1: "OTHER_EVENT",
    2: "BUSINESS_DECLARE_BANKRUPTCY_EVENT",
    3: "BUSINESS_END_ORG_EVENT",
    4: "BUSINESS_MERGE_ORG_EVENT",
    5: "BUSINESS_START_ORG_EVENT",
    6: "CONFLICT_ATTACK_EVENT",
    7: "CONFLICT_DEMONSTRATE_EVENT",
    8: "CONTACT_MEET_EVENT",
    9: "CONTACT_PHONE_WRITE_EVENT",
    10: "JUSTICE_ACQUIT_EVENT",
    11: "JUSTICE_APPEAL_EVENT",
    12: "JUSTICE_ARREST_JAIL_EVENT",
    13: "JUSTICE_CHARGE_INDICT_EVENT",
    14: "JUSTICE_CONVICT_EVENT",
    15: "JUSTICE_EXECUTE_EVENT",
    16: "JUSTICE_EXTRADITE_EVENT",
    17: "JUSTICE_FINE_EVENT",
    18: "JUSTICE_PARDON_EVENT",
    19: "JUSTICE_RELEASE_PAROLE_EVENT",
    20: "JUSTICE_SENTENCE_EVENT",
    21: "JUSTICE_SUE_EVENT",
    22: "JUSTICE_TRIAL_HEARING_EVENT",
    23: "LIFE_BE_BORN_EVENT",
    24: "LIFE_DIE_EVENT",
    25: "LIFE_DIVORCE_EVENT",
    26: "LIFE_INJURE_EVENT",
    27: "LIFE_MARRY_EVENT",
    28: "MOVEMENT_TRANSPORT_EVENT",
    29: "PERSONNEL_ELECT_EVENT",
    30: "PERSONNEL_END_POSITION_EVENT",
    31: "PERSONNEL_NOMINATE_EVENT",
    32: "PERSONNEL_START_POSITION_EVENT",
    33: "QUOTATION_DEFINITE_EVENT",
    34: "QUOTATION_POSSIBLE_EVENT",
    35: "TRANSACTION_TRANSFER_MONEY_EVENT",
    36: "TRANSACTION_TRANSFER_OWNERSHIP_EVENT",
  }

  _NAMES_TO_VALUES = {
    "OTHER_EVENT": 1,
    "BUSINESS_DECLARE_BANKRUPTCY_EVENT": 2,
    "BUSINESS_END_ORG_EVENT": 3,
    "BUSINESS_MERGE_ORG_EVENT": 4,
    "BUSINESS_START_ORG_EVENT": 5,
    "CONFLICT_ATTACK_EVENT": 6,
    "CONFLICT_DEMONSTRATE_EVENT": 7,
    "CONTACT_MEET_EVENT": 8,
    "CONTACT_PHONE_WRITE_EVENT": 9,
    "JUSTICE_ACQUIT_EVENT": 10,
    "JUSTICE_APPEAL_EVENT": 11,
    "JUSTICE_ARREST_JAIL_EVENT": 12,
    "JUSTICE_CHARGE_INDICT_EVENT": 13,
    "JUSTICE_CONVICT_EVENT": 14,
    "JUSTICE_EXECUTE_EVENT": 15,
    "JUSTICE_EXTRADITE_EVENT": 16,
    "JUSTICE_FINE_EVENT": 17,
    "JUSTICE_PARDON_EVENT": 18,
    "JUSTICE_RELEASE_PAROLE_EVENT": 19,
    "JUSTICE_SENTENCE_EVENT": 20,
    "JUSTICE_SUE_EVENT": 21,
    "JUSTICE_TRIAL_HEARING_EVENT": 22,
    "LIFE_BE_BORN_EVENT": 23,
    "LIFE_DIE_EVENT": 24,
    "LIFE_DIVORCE_EVENT": 25,
    "LIFE_INJURE_EVENT": 26,
    "LIFE_MARRY_EVENT": 27,
    "MOVEMENT_TRANSPORT_EVENT": 28,
    "PERSONNEL_ELECT_EVENT": 29,
    "PERSONNEL_END_POSITION_EVENT": 30,
    "PERSONNEL_NOMINATE_EVENT": 31,
    "PERSONNEL_START_POSITION_EVENT": 32,
    "QUOTATION_DEFINITE_EVENT": 33,
    "QUOTATION_POSSIBLE_EVENT": 34,
    "TRANSACTION_TRANSFER_MONEY_EVENT": 35,
    "TRANSACTION_TRANSFER_OWNERSHIP_EVENT": 36,
  }

class StateType(object):
  """
  An enumerated type used to record event types for Situations
  and SituationMentions where situation_type=STATE.
  """
  OTHER_STATE = 1
  ART_INVENTOR_OR_MANUFACTURER_STATE = 37
  ART_OTHER_STATE = 38
  ART_USER_OR_OWNER_STATE = 39
  DISC_STATE = 40
  PHYS_LOCATED_STATE = 41
  PHYS_NEAR_STATE = 42
  PHYS_PART_WHOLE_STATE = 43
  EMP_ORG_EMPLOY_EXECUTIVE_STATE = 44
  EMP_ORG_EMPLOY_STAFF_STATE = 45
  EMP_ORG_EMPLOY_UNDETERMINED_STATE = 46
  EMP_ORG_MEMBER_OF_GROUP_STATE = 47
  EMP_ORG_OTHER_STATE = 48
  EMP_ORG_PARTNER_STATE = 49
  EMP_ORG_SUBSIDIARY_STATE = 50
  GPE_AFF_BASED_IN_STATE = 51
  GPE_AFF_CITIZEN_OR_RESIDENT_STATE = 52
  GPE_AFF_OTHER_STATE = 53
  OTHER_AFF_ETHNIC_STATE = 54
  OTHER_AFF_IDEOLOGY_STATE = 55
  OTHER_AFF_OTHER_STATE = 56
  PER_SOC_BUSINESS_STATE = 57
  PER_SOC_FAMILY_STATE = 58
  PER_SOC_OTHER_STATE = 59
  ART_USER_OWNER_INVENTOR_MANUFACTURER_STATE = 60
  GEN_AFF_CITIZEN_RESIDENT_RELIGION_ETHNICITY_STATE = 61
  GEN_AFF_ORG_LOCATION_STATE = 62
  ORG_AFF_EMPLOYMENT_STATE = 63
  ORG_AFF_FOUNDER_STATE = 64
  ORG_AFF_OWNERSHIP_STATE = 65
  ORG_AFF_STUDENT_ALUM_STATE = 66
  ORG_AFF_SPORTS_AFFILIATION_STATE = 67
  ORG_AFF_INVESTOR_SHAREHOLDER_STATE = 68
  ORG_AFF_MEMBERSHIP_STATE = 69
  PART_WHOLE_ARTIFACT_STATE = 70
  PART_WHOLE_GEOGRAPHICAL_STATE = 71
  PART_WHOLE_SUBSIDIARY_STATE = 72
  PER_SOC_LASTING_PERSONAL_STATE = 73

  _VALUES_TO_NAMES = {
    1: "OTHER_STATE",
    37: "ART_INVENTOR_OR_MANUFACTURER_STATE",
    38: "ART_OTHER_STATE",
    39: "ART_USER_OR_OWNER_STATE",
    40: "DISC_STATE",
    41: "PHYS_LOCATED_STATE",
    42: "PHYS_NEAR_STATE",
    43: "PHYS_PART_WHOLE_STATE",
    44: "EMP_ORG_EMPLOY_EXECUTIVE_STATE",
    45: "EMP_ORG_EMPLOY_STAFF_STATE",
    46: "EMP_ORG_EMPLOY_UNDETERMINED_STATE",
    47: "EMP_ORG_MEMBER_OF_GROUP_STATE",
    48: "EMP_ORG_OTHER_STATE",
    49: "EMP_ORG_PARTNER_STATE",
    50: "EMP_ORG_SUBSIDIARY_STATE",
    51: "GPE_AFF_BASED_IN_STATE",
    52: "GPE_AFF_CITIZEN_OR_RESIDENT_STATE",
    53: "GPE_AFF_OTHER_STATE",
    54: "OTHER_AFF_ETHNIC_STATE",
    55: "OTHER_AFF_IDEOLOGY_STATE",
    56: "OTHER_AFF_OTHER_STATE",
    57: "PER_SOC_BUSINESS_STATE",
    58: "PER_SOC_FAMILY_STATE",
    59: "PER_SOC_OTHER_STATE",
    60: "ART_USER_OWNER_INVENTOR_MANUFACTURER_STATE",
    61: "GEN_AFF_CITIZEN_RESIDENT_RELIGION_ETHNICITY_STATE",
    62: "GEN_AFF_ORG_LOCATION_STATE",
    63: "ORG_AFF_EMPLOYMENT_STATE",
    64: "ORG_AFF_FOUNDER_STATE",
    65: "ORG_AFF_OWNERSHIP_STATE",
    66: "ORG_AFF_STUDENT_ALUM_STATE",
    67: "ORG_AFF_SPORTS_AFFILIATION_STATE",
    68: "ORG_AFF_INVESTOR_SHAREHOLDER_STATE",
    69: "ORG_AFF_MEMBERSHIP_STATE",
    70: "PART_WHOLE_ARTIFACT_STATE",
    71: "PART_WHOLE_GEOGRAPHICAL_STATE",
    72: "PART_WHOLE_SUBSIDIARY_STATE",
    73: "PER_SOC_LASTING_PERSONAL_STATE",
  }

  _NAMES_TO_VALUES = {
    "OTHER_STATE": 1,
    "ART_INVENTOR_OR_MANUFACTURER_STATE": 37,
    "ART_OTHER_STATE": 38,
    "ART_USER_OR_OWNER_STATE": 39,
    "DISC_STATE": 40,
    "PHYS_LOCATED_STATE": 41,
    "PHYS_NEAR_STATE": 42,
    "PHYS_PART_WHOLE_STATE": 43,
    "EMP_ORG_EMPLOY_EXECUTIVE_STATE": 44,
    "EMP_ORG_EMPLOY_STAFF_STATE": 45,
    "EMP_ORG_EMPLOY_UNDETERMINED_STATE": 46,
    "EMP_ORG_MEMBER_OF_GROUP_STATE": 47,
    "EMP_ORG_OTHER_STATE": 48,
    "EMP_ORG_PARTNER_STATE": 49,
    "EMP_ORG_SUBSIDIARY_STATE": 50,
    "GPE_AFF_BASED_IN_STATE": 51,
    "GPE_AFF_CITIZEN_OR_RESIDENT_STATE": 52,
    "GPE_AFF_OTHER_STATE": 53,
    "OTHER_AFF_ETHNIC_STATE": 54,
    "OTHER_AFF_IDEOLOGY_STATE": 55,
    "OTHER_AFF_OTHER_STATE": 56,
    "PER_SOC_BUSINESS_STATE": 57,
    "PER_SOC_FAMILY_STATE": 58,
    "PER_SOC_OTHER_STATE": 59,
    "ART_USER_OWNER_INVENTOR_MANUFACTURER_STATE": 60,
    "GEN_AFF_CITIZEN_RESIDENT_RELIGION_ETHNICITY_STATE": 61,
    "GEN_AFF_ORG_LOCATION_STATE": 62,
    "ORG_AFF_EMPLOYMENT_STATE": 63,
    "ORG_AFF_FOUNDER_STATE": 64,
    "ORG_AFF_OWNERSHIP_STATE": 65,
    "ORG_AFF_STUDENT_ALUM_STATE": 66,
    "ORG_AFF_SPORTS_AFFILIATION_STATE": 67,
    "ORG_AFF_INVESTOR_SHAREHOLDER_STATE": 68,
    "ORG_AFF_MEMBERSHIP_STATE": 69,
    "PART_WHOLE_ARTIFACT_STATE": 70,
    "PART_WHOLE_GEOGRAPHICAL_STATE": 71,
    "PART_WHOLE_SUBSIDIARY_STATE": 72,
    "PER_SOC_LASTING_PERSONAL_STATE": 73,
  }

class TemporalFactType(object):
  """
  An enumerated type used to record event types for Situations
  and SituationMentions where situation_type=TEMPORAL_FACT.
  """
  BEFORE_TEMPORAL_FACT = 1
  AFTER_TEMPORAL_FACT = 2
  SIMULTANEOUS_TEMPORAL_FACT = 3
  INCLUDES_TEMPORAL_FACT = 4
  IS_INCLUDED_BY_TEMPORAL_FACT = 5
  VAGUE_TEMPORAL_FACT = 6

  _VALUES_TO_NAMES = {
    1: "BEFORE_TEMPORAL_FACT",
    2: "AFTER_TEMPORAL_FACT",
    3: "SIMULTANEOUS_TEMPORAL_FACT",
    4: "INCLUDES_TEMPORAL_FACT",
    5: "IS_INCLUDED_BY_TEMPORAL_FACT",
    6: "VAGUE_TEMPORAL_FACT",
  }

  _NAMES_TO_VALUES = {
    "BEFORE_TEMPORAL_FACT": 1,
    "AFTER_TEMPORAL_FACT": 2,
    "SIMULTANEOUS_TEMPORAL_FACT": 3,
    "INCLUDES_TEMPORAL_FACT": 4,
    "IS_INCLUDED_BY_TEMPORAL_FACT": 5,
    "VAGUE_TEMPORAL_FACT": 6,
  }

class TimeMLClass(object):
  """
  An enumeration used to record the TimeML class of a situation
  """
  OCCURRENCE_CLASS = 1
  PERCEPTION_CLASS = 2
  REPORTING_CLASS = 3
  ASPECTUAL_CLASS = 4
  STATE_CLASS = 5
  I_STATE_CLASS = 6
  I_ACTION_CLASS = 7

  _VALUES_TO_NAMES = {
    1: "OCCURRENCE_CLASS",
    2: "PERCEPTION_CLASS",
    3: "REPORTING_CLASS",
    4: "ASPECTUAL_CLASS",
    5: "STATE_CLASS",
    6: "I_STATE_CLASS",
    7: "I_ACTION_CLASS",
  }

  _NAMES_TO_VALUES = {
    "OCCURRENCE_CLASS": 1,
    "PERCEPTION_CLASS": 2,
    "REPORTING_CLASS": 3,
    "ASPECTUAL_CLASS": 4,
    "STATE_CLASS": 5,
    "I_STATE_CLASS": 6,
    "I_ACTION_CLASS": 7,
  }

class TimeMLTense(object):
  """
  An enumeration used to record the TimeML tense of a situation
  """
  FUTURE_TENSE = 1
  INFINITIVE_TENSE = 2
  PAST_TENSE = 3
  PASTPART_TENSE = 4
  PRESENT_TENSE = 5
  PRESPART_TENSE = 6
  NONE_TENSE = 7

  _VALUES_TO_NAMES = {
    1: "FUTURE_TENSE",
    2: "INFINITIVE_TENSE",
    3: "PAST_TENSE",
    4: "PASTPART_TENSE",
    5: "PRESENT_TENSE",
    6: "PRESPART_TENSE",
    7: "NONE_TENSE",
  }

  _NAMES_TO_VALUES = {
    "FUTURE_TENSE": 1,
    "INFINITIVE_TENSE": 2,
    "PAST_TENSE": 3,
    "PASTPART_TENSE": 4,
    "PRESENT_TENSE": 5,
    "PRESPART_TENSE": 6,
    "NONE_TENSE": 7,
  }

class TimeMLAspect(object):
  """
  An enumeration used to record the TimeML aspect of a situation
  """
  PROGRESSIVE_ASPECT = 1
  PERFECTIVE_ASPECT = 2
  PERFECTIVE_PROGRESSIVE_ASPECT = 3
  NONE_ASPECT = 4

  _VALUES_TO_NAMES = {
    1: "PROGRESSIVE_ASPECT",
    2: "PERFECTIVE_ASPECT",
    3: "PERFECTIVE_PROGRESSIVE_ASPECT",
    4: "NONE_ASPECT",
  }

  _NAMES_TO_VALUES = {
    "PROGRESSIVE_ASPECT": 1,
    "PERFECTIVE_ASPECT": 2,
    "PERFECTIVE_PROGRESSIVE_ASPECT": 3,
    "NONE_ASPECT": 4,
  }

class Polarity(object):
  """
  An enumeration used to record the polarity of a situation.
  This is primarily intended for use with SENTIMENT situations.
  """
  POSITIVE_POLARITY = 1
  NEGATIVE_POLARITY = 2
  NEUTRAL_POLARITY = 3
  BOTH_POLARITY = 4

  _VALUES_TO_NAMES = {
    1: "POSITIVE_POLARITY",
    2: "NEGATIVE_POLARITY",
    3: "NEUTRAL_POLARITY",
    4: "BOTH_POLARITY",
  }

  _NAMES_TO_VALUES = {
    "POSITIVE_POLARITY": 1,
    "NEGATIVE_POLARITY": 2,
    "NEUTRAL_POLARITY": 3,
    "BOTH_POLARITY": 4,
  }

class SituationType(object):
  """
  An enumerated type used to record the core types of situations.
  These types form a type hierarchy, as follows:

  * SITUATION
  * FACT
  * CAUSAL_FACT
  * TEMPORAL_FACT
  * EVENT
  * STATE (includes ACE-style relations)
  * PRIVATE_STATE
  * SENTIMENT
  """
  SITUATION = 0
  FACT = 100
  CAUSAL_FACT = 110
  TEMPORAL_FACT = 120
  EVENT = 200
  STATE = 300
  PRIVATE_STATE = 310
  SENTIMENT = 311

  _VALUES_TO_NAMES = {
    0: "SITUATION",
    100: "FACT",
    110: "CAUSAL_FACT",
    120: "TEMPORAL_FACT",
    200: "EVENT",
    300: "STATE",
    310: "PRIVATE_STATE",
    311: "SENTIMENT",
  }

  _NAMES_TO_VALUES = {
    "SITUATION": 0,
    "FACT": 100,
    "CAUSAL_FACT": 110,
    "TEMPORAL_FACT": 120,
    "EVENT": 200,
    "STATE": 300,
    "PRIVATE_STATE": 310,
    "SENTIMENT": 311,
  }


class Argument(object):
  """
  A situation argument, consisting of an argument role and a value.
  Argument values may be Entities or Situations.

  Attributes:
   - role: The relationship between this argument and the situation that
  owns it. The roles that a situation's arguments can take
  depend on the type of the situation (including subtype
  information, such as event_type).
   - entityId: A pointer to the value of this argument, if it is explicitly
  encoded as an Entity or a Situation.
   - situationId: A pointer to the value of this argument, if it is a situation.
   - roleLabel: New roles should usually be added to the enum, but for use
  cases with many varied and possibly dynamic role names, this can be
  used. Presumably this would only be used in a prototype stage of an
  analytic, with roles eventually "hardening" and moving to the enum.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'role', None, None, ), # 1
    (2, TType.STRING, 'entityId', None, None, ), # 2
    (3, TType.STRING, 'situationId', None, None, ), # 3
    (4, TType.STRING, 'roleLabel', None, None, ), # 4
  )

  def __init__(self, role=None, entityId=None, situationId=None, roleLabel=None,):
    self.role = role
    self.entityId = entityId
    self.situationId = situationId
    self.roleLabel = roleLabel

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.role = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.entityId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.situationId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.roleLabel = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Argument')
    if self.role is not None:
      oprot.writeFieldBegin('role', TType.I32, 1)
      oprot.writeI32(self.role)
      oprot.writeFieldEnd()
    if self.entityId is not None:
      oprot.writeFieldBegin('entityId', TType.STRING, 2)
      oprot.writeString(self.entityId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.situationId is not None:
      oprot.writeFieldBegin('situationId', TType.STRING, 3)
      oprot.writeString(self.situationId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.roleLabel is not None:
      oprot.writeFieldBegin('roleLabel', TType.STRING, 4)
      oprot.writeString(self.roleLabel.encode('utf-8'))
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Justification(object):
  """
  Attributes:
   - justificationType: An enumerated value used to describe the way in which the
  justification's mention provides supporting evidence for the
  situation.
   - mentionId: A pointer to the SituationMention itself.
   - tokens: An optional list of pointers to tokens that are (especially)
  relevant to the way in which this mention provides
  justification for the situation. It is left up to individual
  analytics to decide what tokens (if any) they wish to include
  in this field.
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'justificationType', None, None, ), # 1
    (2, TType.STRING, 'mentionId', None, None, ), # 2
    (3, TType.LIST, 'tokens', (TType.STRUCT,(concrete.structure.ttypes.TokenRefSequence, concrete.structure.ttypes.TokenRefSequence.thrift_spec)), None, ), # 3
  )

  def __init__(self, justificationType=None, mentionId=None, tokens=None,):
    self.justificationType = justificationType
    self.mentionId = mentionId
    self.tokens = tokens

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.justificationType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.mentionId = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.tokens = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = concrete.structure.ttypes.TokenRefSequence()
            _elem5.read(iprot)
            self.tokens.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Justification')
    if self.justificationType is not None:
      oprot.writeFieldBegin('justificationType', TType.I32, 1)
      oprot.writeI32(self.justificationType)
      oprot.writeFieldEnd()
    if self.mentionId is not None:
      oprot.writeFieldBegin('mentionId', TType.STRING, 2)
      oprot.writeString(self.mentionId.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.tokens is not None:
      oprot.writeFieldBegin('tokens', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.tokens))
      for iter6 in self.tokens:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class Situation(object):
  """
  A single situation, along with pointers to situation mentions that
  provide evidence for the situation. "Situations" include events,
  relations, facts, sentiments, and beliefs. Each situation has a
  core type (such as EVENT or SENTIMENT), along with an optional
  subtype based on its core type (e.g., event_type=CONTACT_MEET), and
  a set of zero or more unordered arguments.

  Attributes:
   - uuid: Unique identifier for this situation.
   - situationType: The core type of this situation (eg EVENT or SENTIMENT).
   - argumentList: The arguments for this situation. Each argument consists of a
  role and a value. It is possible for an situation to have
  multiple arguments with the same role. Arguments are
  unordered.
   - mentionIdList: Ids of the mentions of this situation in a communication
  (type=SituationMention)
   - justificationList: An list of pointers to SituationMentions that provide
  justification for this situation. These mentions may be either
  direct mentions of the situation, or indirect evidence.
   - eventType: The event type for situations where situation_type=EVENT
   - stateType: The state type for situations where situation_type=STATE
   - temporalFactType: The temporal fact type for situations where situation_type=TEMPORAL_FACT
   - situationKindLemma: This lemma represents a canonical lemma for the situation kind
  when the situation kind cannot be specified by a situation type subtype
  (ex, when using arbitrary verbs or nominalizations as events which do
  not appear in the event_type enumeration).
  If this kind is grounded in a token sequence from the original text, the
  appropriate SituationMention should have a reference to the token sequence.
   - timemlClass: The TimeML class for situations representing TimeML events
   - timemlTense: The TimeML tense for situations representing TimeML events
   - timemlAspect: The TimeML aspect for situations representing TimeML events
   - intensity: An "intensity" rating for this situation, typically ranging from
  0-1. In the case of SENTIMENT situations, this is used to record
  the intensity of the sentiment.
   - polarity: The polarity of this situation. In the case of SENTIMENT
  situations, this is used to record the polarity of the
  sentiment.
   - confidence: A confidence score for this individual situation. You can also
  set a confidence score for an entire SituationSet using the
  SituationSet's metadata.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'uuid', None, None, ), # 1
    (2, TType.I32, 'situationType', None, None, ), # 2
    (3, TType.LIST, 'argumentList', (TType.STRUCT,(Argument, Argument.thrift_spec)), None, ), # 3
    (4, TType.LIST, 'mentionIdList', (TType.STRING,None), None, ), # 4
    (5, TType.LIST, 'justificationList', (TType.STRUCT,(Justification, Justification.thrift_spec)), None, ), # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    None, # 10
    None, # 11
    None, # 12
    None, # 13
    None, # 14
    None, # 15
    None, # 16
    None, # 17
    None, # 18
    None, # 19
    None, # 20
    None, # 21
    None, # 22
    None, # 23
    None, # 24
    None, # 25
    None, # 26
    None, # 27
    None, # 28
    None, # 29
    None, # 30
    None, # 31
    None, # 32
    None, # 33
    None, # 34
    None, # 35
    None, # 36
    None, # 37
    None, # 38
    None, # 39
    None, # 40
    None, # 41
    None, # 42
    None, # 43
    None, # 44
    None, # 45
    None, # 46
    None, # 47
    None, # 48
    None, # 49
    (50, TType.I32, 'eventType', None, None, ), # 50
    (51, TType.I32, 'stateType', None, None, ), # 51
    (52, TType.I32, 'temporalFactType', None, None, ), # 52
    (53, TType.STRING, 'situationKindLemma', None, None, ), # 53
    (54, TType.I32, 'timemlClass', None, None, ), # 54
    (55, TType.I32, 'timemlTense', None, None, ), # 55
    (56, TType.I32, 'timemlAspect', None, None, ), # 56
    None, # 57
    None, # 58
    None, # 59
    None, # 60
    None, # 61
    None, # 62
    None, # 63
    None, # 64
    None, # 65
    None, # 66
    None, # 67
    None, # 68
    None, # 69
    None, # 70
    None, # 71
    None, # 72
    None, # 73
    None, # 74
    None, # 75
    None, # 76
    None, # 77
    None, # 78
    None, # 79
    None, # 80
    None, # 81
    None, # 82
    None, # 83
    None, # 84
    None, # 85
    None, # 86
    None, # 87
    None, # 88
    None, # 89
    None, # 90
    None, # 91
    None, # 92
    None, # 93
    None, # 94
    None, # 95
    None, # 96
    None, # 97
    None, # 98
    None, # 99
    (100, TType.DOUBLE, 'intensity', None, None, ), # 100
    (101, TType.I32, 'polarity', None, None, ), # 101
    None, # 102
    None, # 103
    None, # 104
    None, # 105
    None, # 106
    None, # 107
    None, # 108
    None, # 109
    None, # 110
    None, # 111
    None, # 112
    None, # 113
    None, # 114
    None, # 115
    None, # 116
    None, # 117
    None, # 118
    None, # 119
    None, # 120
    None, # 121
    None, # 122
    None, # 123
    None, # 124
    None, # 125
    None, # 126
    None, # 127
    None, # 128
    None, # 129
    None, # 130
    None, # 131
    None, # 132
    None, # 133
    None, # 134
    None, # 135
    None, # 136
    None, # 137
    None, # 138
    None, # 139
    None, # 140
    None, # 141
    None, # 142
    None, # 143
    None, # 144
    None, # 145
    None, # 146
    None, # 147
    None, # 148
    None, # 149
    None, # 150
    None, # 151
    None, # 152
    None, # 153
    None, # 154
    None, # 155
    None, # 156
    None, # 157
    None, # 158
    None, # 159
    None, # 160
    None, # 161
    None, # 162
    None, # 163
    None, # 164
    None, # 165
    None, # 166
    None, # 167
    None, # 168
    None, # 169
    None, # 170
    None, # 171
    None, # 172
    None, # 173
    None, # 174
    None, # 175
    None, # 176
    None, # 177
    None, # 178
    None, # 179
    None, # 180
    None, # 181
    None, # 182
    None, # 183
    None, # 184
    None, # 185
    None, # 186
    None, # 187
    None, # 188
    None, # 189
    None, # 190
    None, # 191
    None, # 192
    None, # 193
    None, # 194
    None, # 195
    None, # 196
    None, # 197
    None, # 198
    None, # 199
    (200, TType.DOUBLE, 'confidence', None, None, ), # 200
  )

  def __init__(self, uuid=None, situationType=None, argumentList=None, mentionIdList=None, justificationList=None, eventType=None, stateType=None, temporalFactType=None, situationKindLemma=None, timemlClass=None, timemlTense=None, timemlAspect=None, intensity=None, polarity=None, confidence=None,):
    self.uuid = uuid
    self.situationType = situationType
    self.argumentList = argumentList
    self.mentionIdList = mentionIdList
    self.justificationList = justificationList
    self.eventType = eventType
    self.stateType = stateType
    self.temporalFactType = temporalFactType
    self.situationKindLemma = situationKindLemma
    self.timemlClass = timemlClass
    self.timemlTense = timemlTense
    self.timemlAspect = timemlAspect
    self.intensity = intensity
    self.polarity = polarity
    self.confidence = confidence

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.uuid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.situationType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.argumentList = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = Argument()
            _elem12.read(iprot)
            self.argumentList.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.mentionIdList = []
          (_etype16, _size13) = iprot.readListBegin()
          for _i17 in xrange(_size13):
            _elem18 = iprot.readString().decode('utf-8')
            self.mentionIdList.append(_elem18)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.justificationList = []
          (_etype22, _size19) = iprot.readListBegin()
          for _i23 in xrange(_size19):
            _elem24 = Justification()
            _elem24.read(iprot)
            self.justificationList.append(_elem24)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 50:
        if ftype == TType.I32:
          self.eventType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 51:
        if ftype == TType.I32:
          self.stateType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 52:
        if ftype == TType.I32:
          self.temporalFactType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 53:
        if ftype == TType.STRING:
          self.situationKindLemma = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 54:
        if ftype == TType.I32:
          self.timemlClass = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 55:
        if ftype == TType.I32:
          self.timemlTense = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 56:
        if ftype == TType.I32:
          self.timemlAspect = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 100:
        if ftype == TType.DOUBLE:
          self.intensity = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 101:
        if ftype == TType.I32:
          self.polarity = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 200:
        if ftype == TType.DOUBLE:
          self.confidence = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Situation')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRING, 1)
      oprot.writeString(self.uuid.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.situationType is not None:
      oprot.writeFieldBegin('situationType', TType.I32, 2)
      oprot.writeI32(self.situationType)
      oprot.writeFieldEnd()
    if self.argumentList is not None:
      oprot.writeFieldBegin('argumentList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.argumentList))
      for iter25 in self.argumentList:
        iter25.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.mentionIdList is not None:
      oprot.writeFieldBegin('mentionIdList', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.mentionIdList))
      for iter26 in self.mentionIdList:
        oprot.writeString(iter26.encode('utf-8'))
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.justificationList is not None:
      oprot.writeFieldBegin('justificationList', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.justificationList))
      for iter27 in self.justificationList:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.eventType is not None:
      oprot.writeFieldBegin('eventType', TType.I32, 50)
      oprot.writeI32(self.eventType)
      oprot.writeFieldEnd()
    if self.stateType is not None:
      oprot.writeFieldBegin('stateType', TType.I32, 51)
      oprot.writeI32(self.stateType)
      oprot.writeFieldEnd()
    if self.temporalFactType is not None:
      oprot.writeFieldBegin('temporalFactType', TType.I32, 52)
      oprot.writeI32(self.temporalFactType)
      oprot.writeFieldEnd()
    if self.situationKindLemma is not None:
      oprot.writeFieldBegin('situationKindLemma', TType.STRING, 53)
      oprot.writeString(self.situationKindLemma.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.timemlClass is not None:
      oprot.writeFieldBegin('timemlClass', TType.I32, 54)
      oprot.writeI32(self.timemlClass)
      oprot.writeFieldEnd()
    if self.timemlTense is not None:
      oprot.writeFieldBegin('timemlTense', TType.I32, 55)
      oprot.writeI32(self.timemlTense)
      oprot.writeFieldEnd()
    if self.timemlAspect is not None:
      oprot.writeFieldBegin('timemlAspect', TType.I32, 56)
      oprot.writeI32(self.timemlAspect)
      oprot.writeFieldEnd()
    if self.intensity is not None:
      oprot.writeFieldBegin('intensity', TType.DOUBLE, 100)
      oprot.writeDouble(self.intensity)
      oprot.writeFieldEnd()
    if self.polarity is not None:
      oprot.writeFieldBegin('polarity', TType.I32, 101)
      oprot.writeI32(self.polarity)
      oprot.writeFieldEnd()
    if self.confidence is not None:
      oprot.writeFieldBegin('confidence', TType.DOUBLE, 200)
      oprot.writeDouble(self.confidence)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SituationSet(object):
  """
  A theory about the set of situations that are present in a
  message. See also: Situation

  Attributes:
   - uuid: Unique identifier for this set.
   - metadata: Information about where this set came from.
   - situationList: List of mentions in this set.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'uuid', None, None, ), # 1
    (2, TType.STRUCT, 'metadata', (concrete.metadata.ttypes.AnnotationMetadata, concrete.metadata.ttypes.AnnotationMetadata.thrift_spec), None, ), # 2
    (3, TType.LIST, 'situationList', (TType.STRUCT,(Situation, Situation.thrift_spec)), None, ), # 3
  )

  def __init__(self, uuid=None, metadata=None, situationList=None,):
    self.uuid = uuid
    self.metadata = metadata
    self.situationList = situationList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.uuid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
          self.metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.situationList = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = Situation()
            _elem33.read(iprot)
            self.situationList.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SituationSet')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRING, 1)
      oprot.writeString(self.uuid.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
      self.metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.situationList is not None:
      oprot.writeFieldBegin('situationList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.situationList))
      for iter34 in self.situationList:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SituationMention(object):
  """
  A concrete mention of a situation, where "situations" include
  events, relations, facts, sentiments, and beliefs. Each situation
  has a core type (such as EVENT or SENTIMENT), along with an
  optional subtype based on its core type (e.g.,
  event_type=CONTACT_MEET), and a set of zero or more unordered
  arguments.

  Attributes:
   - uuid: Unique identifier for this situation.
   - text: The text content of this situation mention. This field is
  often redundant with the 'tokens' field, and may not
  be generated by all analytics.
   - situationType: The core type of this situation (eg EVENT or SENTIMENT)
   - argumentList: The arguments for this situation mention. Each argument
  consists of a role and a value. It is possible for an situation
  to have multiple arguments with the same role. Arguments are
  unordered.
   - eventType: The event type for situations where situation_type=EVENT
   - stateType: The state type for situations where situation_type=STATE
   - situationKindLemma: This lemma represents a canonical lemma for the situation kind
  when the situation kind cannot be specified by a situation type subtype
  (ex, when using arbitrary verbs or nominalizations as events which do
  not appear in the event_type enumeration).
  If this kind is grounded in a token sequence from the original text, the
  SituationMention should have a reference to the token sequence.
   - intensity: An "intensity" rating for the situation, typically ranging from
  0-1. In the case of SENTIMENT situations, this is used to record
  the intensity of the sentiment.
   - polarity: The polarity of this situation. In the case of SENTIMENT
  situations, this is used to record the polarity of the
  sentiment.
   - tokens: An optional pointer to tokens that are (especially)
  relevant to this situation mention. It is left up to individual
  analytics to decide what tokens (if any) they wish to include in
  this field. In particular, it is not specified whether the
  arguments' tokens should be included.
   - confidence: A confidence score for this individual situation mention. You
  can also set a confidence score for an entire SituationMentionSet
  using the SituationMentionSet's metadata.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'uuid', None, None, ), # 1
    (2, TType.STRING, 'text', None, None, ), # 2
    (3, TType.I32, 'situationType', None, None, ), # 3
    (4, TType.LIST, 'argumentList', (TType.STRUCT,(Argument, Argument.thrift_spec)), None, ), # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    None, # 10
    None, # 11
    None, # 12
    None, # 13
    None, # 14
    None, # 15
    None, # 16
    None, # 17
    None, # 18
    None, # 19
    None, # 20
    None, # 21
    None, # 22
    None, # 23
    None, # 24
    None, # 25
    None, # 26
    None, # 27
    None, # 28
    None, # 29
    None, # 30
    None, # 31
    None, # 32
    None, # 33
    None, # 34
    None, # 35
    None, # 36
    None, # 37
    None, # 38
    None, # 39
    None, # 40
    None, # 41
    None, # 42
    None, # 43
    None, # 44
    None, # 45
    None, # 46
    None, # 47
    None, # 48
    None, # 49
    (50, TType.I32, 'eventType', None, None, ), # 50
    (51, TType.I32, 'stateType', None, None, ), # 51
    None, # 52
    (53, TType.STRING, 'situationKindLemma', None, None, ), # 53
    None, # 54
    None, # 55
    None, # 56
    None, # 57
    None, # 58
    None, # 59
    None, # 60
    None, # 61
    None, # 62
    None, # 63
    None, # 64
    None, # 65
    None, # 66
    None, # 67
    None, # 68
    None, # 69
    None, # 70
    None, # 71
    None, # 72
    None, # 73
    None, # 74
    None, # 75
    None, # 76
    None, # 77
    None, # 78
    None, # 79
    None, # 80
    None, # 81
    None, # 82
    None, # 83
    None, # 84
    None, # 85
    None, # 86
    None, # 87
    None, # 88
    None, # 89
    None, # 90
    None, # 91
    None, # 92
    None, # 93
    None, # 94
    None, # 95
    None, # 96
    None, # 97
    None, # 98
    None, # 99
    (100, TType.DOUBLE, 'intensity', None, None, ), # 100
    (101, TType.I32, 'polarity', None, None, ), # 101
    None, # 102
    None, # 103
    None, # 104
    None, # 105
    None, # 106
    None, # 107
    None, # 108
    None, # 109
    None, # 110
    None, # 111
    None, # 112
    None, # 113
    None, # 114
    None, # 115
    None, # 116
    None, # 117
    None, # 118
    None, # 119
    None, # 120
    None, # 121
    None, # 122
    None, # 123
    None, # 124
    None, # 125
    None, # 126
    None, # 127
    None, # 128
    None, # 129
    None, # 130
    None, # 131
    None, # 132
    None, # 133
    None, # 134
    None, # 135
    None, # 136
    None, # 137
    None, # 138
    None, # 139
    None, # 140
    None, # 141
    None, # 142
    None, # 143
    None, # 144
    None, # 145
    None, # 146
    None, # 147
    None, # 148
    None, # 149
    (150, TType.STRUCT, 'tokens', (concrete.structure.ttypes.TokenRefSequence, concrete.structure.ttypes.TokenRefSequence.thrift_spec), None, ), # 150
    None, # 151
    None, # 152
    None, # 153
    None, # 154
    None, # 155
    None, # 156
    None, # 157
    None, # 158
    None, # 159
    None, # 160
    None, # 161
    None, # 162
    None, # 163
    None, # 164
    None, # 165
    None, # 166
    None, # 167
    None, # 168
    None, # 169
    None, # 170
    None, # 171
    None, # 172
    None, # 173
    None, # 174
    None, # 175
    None, # 176
    None, # 177
    None, # 178
    None, # 179
    None, # 180
    None, # 181
    None, # 182
    None, # 183
    None, # 184
    None, # 185
    None, # 186
    None, # 187
    None, # 188
    None, # 189
    None, # 190
    None, # 191
    None, # 192
    None, # 193
    None, # 194
    None, # 195
    None, # 196
    None, # 197
    None, # 198
    None, # 199
    (200, TType.DOUBLE, 'confidence', None, None, ), # 200
  )

  def __init__(self, uuid=None, text=None, situationType=None, argumentList=None, eventType=None, stateType=None, situationKindLemma=None, intensity=None, polarity=None, tokens=None, confidence=None,):
    self.uuid = uuid
    self.text = text
    self.situationType = situationType
    self.argumentList = argumentList
    self.eventType = eventType
    self.stateType = stateType
    self.situationKindLemma = situationKindLemma
    self.intensity = intensity
    self.polarity = polarity
    self.tokens = tokens
    self.confidence = confidence

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.uuid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.text = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.situationType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.argumentList = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = Argument()
            _elem40.read(iprot)
            self.argumentList.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 50:
        if ftype == TType.I32:
          self.eventType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 51:
        if ftype == TType.I32:
          self.stateType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 53:
        if ftype == TType.STRING:
          self.situationKindLemma = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 100:
        if ftype == TType.DOUBLE:
          self.intensity = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 101:
        if ftype == TType.I32:
          self.polarity = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 150:
        if ftype == TType.STRUCT:
          self.tokens = concrete.structure.ttypes.TokenRefSequence()
          self.tokens.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 200:
        if ftype == TType.DOUBLE:
          self.confidence = iprot.readDouble();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SituationMention')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRING, 1)
      oprot.writeString(self.uuid.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.text is not None:
      oprot.writeFieldBegin('text', TType.STRING, 2)
      oprot.writeString(self.text.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.situationType is not None:
      oprot.writeFieldBegin('situationType', TType.I32, 3)
      oprot.writeI32(self.situationType)
      oprot.writeFieldEnd()
    if self.argumentList is not None:
      oprot.writeFieldBegin('argumentList', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.argumentList))
      for iter41 in self.argumentList:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.eventType is not None:
      oprot.writeFieldBegin('eventType', TType.I32, 50)
      oprot.writeI32(self.eventType)
      oprot.writeFieldEnd()
    if self.stateType is not None:
      oprot.writeFieldBegin('stateType', TType.I32, 51)
      oprot.writeI32(self.stateType)
      oprot.writeFieldEnd()
    if self.situationKindLemma is not None:
      oprot.writeFieldBegin('situationKindLemma', TType.STRING, 53)
      oprot.writeString(self.situationKindLemma.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.intensity is not None:
      oprot.writeFieldBegin('intensity', TType.DOUBLE, 100)
      oprot.writeDouble(self.intensity)
      oprot.writeFieldEnd()
    if self.polarity is not None:
      oprot.writeFieldBegin('polarity', TType.I32, 101)
      oprot.writeI32(self.polarity)
      oprot.writeFieldEnd()
    if self.tokens is not None:
      oprot.writeFieldBegin('tokens', TType.STRUCT, 150)
      self.tokens.write(oprot)
      oprot.writeFieldEnd()
    if self.confidence is not None:
      oprot.writeFieldBegin('confidence', TType.DOUBLE, 200)
      oprot.writeDouble(self.confidence)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SituationMentionSet(object):
  """
  A theory about the set of situation mentions that are present in a
  message. See also: SituationMention

  Attributes:
   - uuid: Unique identifier for this set.
   - metadata: Information about where this set came from.
   - mentionList: List of mentions in this set.
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'uuid', None, None, ), # 1
    (2, TType.STRUCT, 'metadata', (concrete.metadata.ttypes.AnnotationMetadata, concrete.metadata.ttypes.AnnotationMetadata.thrift_spec), None, ), # 2
    (3, TType.LIST, 'mentionList', (TType.STRUCT,(SituationMention, SituationMention.thrift_spec)), None, ), # 3
  )

  def __init__(self, uuid=None, metadata=None, mentionList=None,):
    self.uuid = uuid
    self.metadata = metadata
    self.mentionList = mentionList

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.uuid = iprot.readString().decode('utf-8')
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.metadata = concrete.metadata.ttypes.AnnotationMetadata()
          self.metadata.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.mentionList = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = SituationMention()
            _elem47.read(iprot)
            self.mentionList.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SituationMentionSet')
    if self.uuid is not None:
      oprot.writeFieldBegin('uuid', TType.STRING, 1)
      oprot.writeString(self.uuid.encode('utf-8'))
      oprot.writeFieldEnd()
    if self.metadata is not None:
      oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
      self.metadata.write(oprot)
      oprot.writeFieldEnd()
    if self.mentionList is not None:
      oprot.writeFieldBegin('mentionList', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.mentionList))
      for iter48 in self.mentionList:
        iter48.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
